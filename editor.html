<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Vi-inspired Editor Final (with id,text)</title>
<script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
<style>
body { font-family:sans-serif; margin:0; }
.toolbar { display:flex; gap:8px; padding:6px; background:#eee; border-bottom:1px solid #ccc; flex-wrap:wrap; }
.line { padding:4px 8px; border-bottom:1px dashed #ddd; cursor:pointer; min-height:1.5em; }
.line.selected { background:#d0ebff; }
.line:empty::before { content:"\00a0"; }
.line, .line-input {
  white-space: pre;
  overflow-x: auto;
  min-height: 2em;
  line-height: 2em;
  padding: 4px 8px;
  font-size: 16px;
  box-sizing: border-box; 
}
input.line-input {
  width:100%;
  border:none;
  outline:none;
  padding:4px 8px;
  border-bottom:1px dashed #ddd;
  font-family:inherit;
  font-size:inherit;
}
.toolbar {
  position: sticky;
  top: 0;
  z-index: 1000;
  background: #eee;
  padding: 6px;
  border-bottom: 1px solid #ccc;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}
</style>
</head>
<body x-data="editorApp">

<!-- 툴바 -->
<div class="toolbar">
  <button @click="toggleMode()">모드: <span x-text="mode"></span></button>
  <template x-if="mode==='editor'">
    <div style="display:flex; gap:4px;">
      <button @click="manualCut()">✂ 잘라내기</button>
      <button @click="manualCopy()">📄 복사</button>
      <button @click="paste()">📋 붙여넣기</button>
      <button @click="replace()">♻ 치환</button>
      <button @click="selectAll()">전체 선택</button>
      <button @click="deleteSelection()">선택 영역 삭제</button>
    </div>
  </template>
  <button @click="undo()" :disabled="undoStack.length===0">↩ undo</button>
  <button @click="redo()" :disabled="redoStack.length===0">↪ redo</button>
</div>

<!-- 본문 -->
<div>
  <!-- 에디터 모드 -->
  <template x-if="mode==='editor'">
    <div>
      <template x-for="(line, i) in lines" :key="line.id">
        <div class="line"
             :class="{selected: selection && i>=selection.start && i<=selection.end}"
             @click="toggleSelect(i)"
             x-text="line.text">
        </div>
      </template>
    </div>
  </template>

  <!-- 텍스트 모드 -->
  <template x-if="mode==='text'">
    <div>
      <template x-for="(line,i) in lines" :key="line.id">
        <input
          class="line-input"
          type="text"
          x-model="lines[i].text"
          @keyup.enter.prevent="insertLine(i, $event)"
@keyup.backspace="mergeWithPrev(i,$event)"
          enterkeyhint="enter"
        />

      </template>
    </div>
  </template>
</div>

<script>
document.addEventListener("alpine:init",()=>{
Alpine.data("editorApp",()=>({
mode:"editor",
lines:[
  {id:1,text:"첫 줄"},
  {id:2,text:"둘째 줄"},
  {id:3,text:"셋째 줄"}
],
selection:null,
undoStack:[],
redoStack:[],
nextId:4,

genId(){ return this.nextId++; },

toggleMode(){ this.mode = this.mode==="editor" ? "text":"editor"; this.selection=null; },

toggleSelect(i) {
  if (!this.selection) {
    this.selection = { start: i, end: i };
    this.lastClicked = i;
    return;
  }
  if (i >= this.lastClicked) {
    this.selection.start = this.lastClicked;
    this.selection.end = i;
  } else {
    this.selection.start = i;
    this.selection.end = this.lastClicked;
  }
  this.lastClicked = i;
},

getSelectedLines(){
  if(!this.selection) return [];
  return this.lines.slice(this.selection.start,this.selection.end+1);
},
selectAll() {
  if(this.lines.length === 0) return;
  this.selection = { start: 0, end: this.lines.length - 1 };
},

deleteSelection() {
  if(!this.selection) return;
  const { start, end } = this.selection;
  const oldLines = this.lines.slice(start, end + 1).map(l=>({...l}));

  const cmd = {
    do: () => {
      this.lines.splice(start, end - start + 1);
      this.selection = null;
    },
    undo: () => {
      this.lines.splice(start, 0, ...oldLines);
    }
  };

  this.execute(cmd);
},

execute(cmd){
  cmd.do();
  this.undoStack.push(cmd);
  this.redoStack=[];
},

async writeClipboard(text,manual=false){
  if(!manual) return;
  try{ await navigator.clipboard.writeText(text); } 
  catch(e){ console.warn("Clipboard write failed",e); }
},

manualCopy(){
  if(!this.selection) return;
  const text = this.getSelectedLines().map(l=>l.text).join('\n');
  this.writeClipboard(text,true);
  this.selection=null;
},

manualCut(){
  if(!this.selection) return;
  const {start,end}=this.selection;
  const oldLines = this.getSelectedLines().map(l=>({...l}));
  const cmd = {
    do:()=>{ this.lines.splice(start,end-start+1); this.selection=null; },
    undo:()=>{ this.lines.splice(start,0,...oldLines); },
    manual:()=>this.writeClipboard(oldLines.map(l=>l.text).join('\n'),true)
  };
  this.execute(cmd);
  cmd.manual();
},

async paste(){
  try{
    const text = await navigator.clipboard.readText();
    if(!text) return;
    const linesToInsert = text.split('\n').map(t=>({id:this.genId(),text:t}));
    const index = this.selection ? this.selection.end : this.lines.length-1;
    const cmd = {
      do:()=>{ this.lines.splice(index+1,0,...linesToInsert); this.selection=null; },
      undo:()=>{ this.lines.splice(index+1,linesToInsert.length); }
    };
    this.execute(cmd);
  }catch(e){ console.warn("Clipboard read failed",e); }
},

async replace(){
  if(!this.selection) return;
  const {start,end}=this.selection;
  try{
    const text = await navigator.clipboard.readText();
    if(!text) return;
    const newLines = text.split('\n').map(t=>({id:this.genId(),text:t}));
    const oldLines = this.lines.slice(start,end+1).map(l=>({...l}));
    const cmd = {
      do:()=>{ this.lines.splice(start,end-start+1,...newLines); this.selection=null; },
      undo:()=>{ this.lines.splice(start,newLines.length,...oldLines); }
    };
    this.execute(cmd);
  }catch(e){ console.warn("Clipboard read failed",e); }
},

insertLine(i, event) {
  const input = event.target;
  const cursorPos = input.selectionStart;
  const value = input.value;

  const before = value.slice(0, cursorPos);
  const after = value.slice(cursorPos);
  const oldLine = {...this.lines[i]};

  const cmd = {
    do: () => {
      this.lines.splice(i, 1,
        {id:this.genId(), text: before},
        {id:this.genId(), text: after}
      );
      setTimeout(() => {
        const inputs = document.querySelectorAll('input.line-input');
        const nextInput = inputs[i + 1];
        if (nextInput) {
          nextInput.focus();
          nextInput.setSelectionRange(0, 0);
        }
      }, 0);
    },
    undo: () => {
      this.lines.splice(i, 2, oldLine);
      setTimeout(() => {
        const inputs = document.querySelectorAll('input.line-input');
        if (inputs[i]) inputs[i].focus();
      }, 0);
    }
  };

  this.execute(cmd);
},
mergeWithPrev(i, event) {
  const input = event.target;
  const cursorPos = input.selectionStart;

  if(cursorPos !== 0) return;
  if(i === 0) return;
event.preventDefault();
  const prevLine = {...this.lines[i-1]};
  const currLine = {...this.lines[i]};

  const cmd = {
    do: () => {
      // 이전 줄과 현재 줄 합치기
      const mergedText = prevLine.text + currLine.text;
      this.lines.splice(i-1, 2, {id: this.genId(), text: mergedText});

      // DOM 업데이트 후 focus 및 커서 위치
      setTimeout(() => {
        const inputs = document.querySelectorAll('input.line-input');
        const newInput = inputs[i-1];
        if(newInput) {
          newInput.focus();
          newInput.setSelectionRange(prevLine.text.length, prevLine.text.length);
        }
      }, 0);
    },
    undo: () => {
      // 합치기 전 상태 복원
      this.lines.splice(i-1, 1, prevLine, currLine);
      setTimeout(() => {
        const inputs = document.querySelectorAll('input.line-input');
        const currInput = inputs[i];
        if(currInput) {
          currInput.focus();
          currInput.setSelectionRange(0,0);
        }
      },0);
    }
  };

  this.execute(cmd);
},

undo(){
  if(this.undoStack.length===0) return;
  const cmd = this.undoStack.pop();
  cmd.undo?.();
  this.redoStack.push(cmd);
},

redo(){
  if(this.redoStack.length===0) return;
  const cmd = this.redoStack.pop();
  cmd.do?.();
  this.undoStack.push(cmd);
}

}))
});
</script>

</body>
</html>